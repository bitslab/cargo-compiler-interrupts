use std::fs;
use std::path::{Path, PathBuf};
use std::process::{Command, Output};
use std::sync::Arc;

use cargo_util::paths;
use color_eyre::eyre::{bail, eyre, WrapErr};
use color_eyre::Help;
use filetime::FileTime;
use tracing::{debug, info};

use crate::args::BuildArgs;
use crate::config::Config;
use crate::{cargo, util, CIResult};

pub fn exec(args: BuildArgs) -> CIResult<()> {
    let config = Config::load()?;
    if !Path::new(&config.path).exists() {
        return Err(eyre!("Failed to locate the Compiler Interrupts library")
            .suggestion("Run `cargo lib-ci --install` to install the library"));
    }

    println!("Compiling...");

    let mut old_timestamp_binary_files = vec![];

    let args = Arc::new(args);

    if let Ok(deps_dir) = util::target_dir(&args.target, &args.release, "deps") {
        let binary_files = {
            let v = util::scan_dir(&deps_dir, |_, extension| extension == None)?;
            v.into_iter()
                .filter(|path| fs::metadata(path).unwrap().is_file())
                .collect::<Vec<PathBuf>>()
        };
        old_timestamp_binary_files = binary_files
            .iter()
            .map(|e| paths::mtime(e).unwrap())
            .collect::<Vec<FileTime>>();
    }

    // run `cargo build`
    let cargo_build_output = cargo::build(&args)?;

    let deps_dir = util::target_dir(&args.target, &args.release, "deps")?;

    let binary_files = {
        let v = util::scan_dir(&deps_dir, |_, extension| extension == None)?;
        v.into_iter()
            .filter(|path| fs::metadata(path).unwrap().is_file())
            .collect::<Vec<PathBuf>>()
    };

    let new_timestamp_binary_files = binary_files
        .iter()
        .map(|e| paths::mtime(e).unwrap())
        .collect::<Vec<FileTime>>();

    let num_newer_binary_file = if old_timestamp_binary_files.is_empty() {
        new_timestamp_binary_files.len()
    } else {
        old_timestamp_binary_files
            .iter()
            .zip(&new_timestamp_binary_files)
            .filter(|&(a, b)| a > b)
            .count()
    };

    if num_newer_binary_file == 0 {
        println!("Nothing to integrate, all fresh");
        return Ok(());
    }

    println!("Integrating...");

    // get *.ll files
    let ll_files = util::scan_dir(&deps_dir, |stem, extension| {
        // *.rcgu.ll are intermediate files generated by `rustc -C save-temps`
        let stem = stem.unwrap_or_default();
        stem.contains("rcgu") && !stem.contains("_ci") && extension == Some("ll")
    })?;

    // run CI integration
    let mut handlers = vec![];
    for file in ll_files {
        let config = config.clone();
        let handler = std::thread::spawn(move || {
            pre_ci_integration(&file)?;
            ci_integration(&file, &config)?;
            post_ci_integration(&file)?;
            Ok::<(), color_eyre::eyre::Error>(())
        });
        handlers.push(handler);
    }
    for handler in handlers {
        handler.join().expect("failed to join thread")?;
    }

    // run linker
    linker(&args, cargo_build_output, num_newer_binary_file)?;

    // copy output file
    let binary_files = {
        let v = util::scan_dir(&deps_dir, |_, extension| extension == None)?;
        v.into_iter()
            .filter(|path| fs::metadata(path).unwrap().is_file())
            .collect::<Vec<PathBuf>>()
    };

    for file in binary_files {
        let name = file.file_name().unwrap();
        let parent = file.parent().unwrap();
        let path = parent.with_file_name(name);
        util::cp(&file, &path)?;
    }

    println!("Done. Run `cargo run-ci` to run the integrated binary");

    Ok(())
}

fn pre_ci_integration(file: &PathBuf) -> CIResult<Output> {
    // first `opt` pass, pre-CI-integration optimization
    debug!("pre-integration: {}", file.display());
    let file_name = file
        .file_stem()
        .and_then(|s| s.to_str())
        .ok_or_else(|| eyre!("failed to get file stem"))?;
    let out_file = file.with_file_name(format!("{}_opt.ll", file_name));
    let args = vec![
        "-S",
        "-postdomtree",
        "-mem2reg",
        "-indvars",
        "-loop-simplify",
        "-branch-prob",
        "-scalar-evolution",
    ]
    .iter()
    .map(|s| s.to_string())
    .collect::<Vec<String>>();

    let output = util::opt(args, &file, &&out_file)?;
    Ok(output)
}

fn ci_integration(file: &PathBuf, config: &Config) -> CIResult<Output> {
    // second `opt` pass, integrate CI
    debug!("integration: {}", file.display());

    // get the binary and proc_macro name
    let mut bin_target_names = vec![];
    let metadata = cargo::metadata()?;
    for package in metadata.packages {
        for target in package.targets {
            let mut flag = true;
            for crate_type in target.crate_types {
                if crate_type != "bin" {
                    flag = false;
                }
            }
            for kind in target.kind {
                if kind != "bin" {
                    flag = false;
                }
            }
            if flag {
                bin_target_names.push(target.name.replace("-", "_"));
            }
        }
    }

    let file_name = file
        .file_stem()
        .and_then(|s| s.to_str())
        .ok_or_else(|| eyre!("failed to get file stem"))?;

    let in_file = file.with_file_name(format!("{}_opt.ll", file_name));
    let out_file = file.with_file_name(format!("{}_ci.ll", file_name));

    // file_name: ci_demo.3imf9adxlnlmq03x.rcgu -> ci_demo
    let file_name = file_name.split(".").collect::<Vec<&str>>()[0].to_string();

    // skip "compiler-interrupt" crate
    let skip_crates = vec!["compiler_interrupt"];

    if skip_crates.iter().any(|skip| file_name.contains(skip)) {
        // make a dummy _ci.ll file
        let output = util::cp(&in_file, &out_file)?;
        return Ok(output);
    }

    // define `LocalLC` only if it is a binary target
    let def_clock = match bin_target_names.contains(&file_name) {
        true => "-defclock=1",
        false => "-defclock=0",
    };

    let mut args = ["-S", "-load", &config.path, "-logicalclock", def_clock]
        .iter()
        .map(|s| s.to_string())
        .collect::<Vec<String>>();

    args.extend(config.args.clone());

    let output = util::opt(&args, &in_file, &out_file)?;
    Ok(output)
}

fn post_ci_integration(file: &PathBuf) -> CIResult<()> {
    debug!("post-integration: {}", file.display());
    let file_name = file
        .file_stem()
        .and_then(|s| s.to_str())
        .ok_or_else(|| eyre!("failed to get file stem"))?;
    let opt_file = file.with_file_name(format!("{}_opt.ll", file_name));
    let ci_file = file.with_file_name(format!("{}_ci.ll", file_name));

    // transform IR bitcode to object file
    util::llc(&ci_file)?;

    // clean *_opt.ll
    fs::remove_file(opt_file.clone())
        .wrap_err(format!("failed to remove file: {}", opt_file.display()))?;

    Ok(())
}

fn linker(
    args: &BuildArgs,
    cargo_build_output: Output,
    num_newer_binary_file: usize,
) -> CIResult<()> {
    // parse output from `cargo build` to get the final `cc` linker command
    debug!("running linker");
    let stdout = String::from_utf8_lossy(&cargo_build_output.stdout);
    let stdout = stdout.lines().collect::<Vec<&str>>();
    let cc_commands = stdout.iter().rev().take(num_newer_binary_file);

    for cc in cc_commands {
        debug!("cc: {}", cc);
        let cc = cc.replace("\"", "");
        let mut cc = cc
            .split_ascii_whitespace()
            .map(str::to_string)
            .collect::<Vec<String>>();

        let object_files = cc
            .iter_mut()
            .filter(|e| e.contains(".o") && !e.contains("_ci"));
        for file in object_files {
            // find the object file that contains the symbol for rust memory allocator
            // it doesn't get CI-integrated so we will have to find it for later use
            // we also need to invoke `rustc` with `-C save-temps` flags to not to delete the
            // temporary object file that contain allocator symbols

            // use `nm` tool to display symbol name
            // `-j` to just display the symbol names, `-U` to not display undefined symbols
            debug!("finding allocator shim: {}", file);
            let output = Command::new("nm").arg("-jU").arg(file.clone()).output()?;
            if !output.status.success() {
                info!("status code: {:?}", output.status);
                info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
                info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
                bail!("`nm` returned failed status code");
            }
            let stdout = String::from_utf8_lossy(&output.stdout);
            if !stdout.contains("___rust_alloc") {
                let file_name = PathBuf::from(file.clone());
                let mut ci_file = file_name.clone();
                let file_name = file_name
                    .file_stem()
                    .and_then(|s| s.to_str())
                    .ok_or_else(|| eyre!("failed to get file stem"))?;
                ci_file.set_file_name(format!("{}_ci.o", file_name));
                *file = ci_file.into_os_string().into_string().unwrap();
            }
        }

        let deps_rlib_files = cc
            .iter()
            .filter(|e| e.contains("deps") && e.contains(".rlib"));
        for file in deps_rlib_files {
            debug!("replacing object file: {}", file);
            replace_obj_file(args, file)?;
        }

        // execute
        debug!("executing cc");
        let mut iter = cc.iter();
        let mut cmd = Command::new(iter.next().unwrap());
        for arg in iter {
            cmd.arg(arg);
        }

        let output = cmd.output().wrap_err("failed to execute `cc`")?;

        if !output.status.success() {
            info!("status code: {:?}", output.status);
            info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
            info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
            bail!("`cc` returned failed status code");
        }
    }

    let deps_dir = util::target_dir(&args.target, &args.release, "deps")?;

    // clean up rcgu.* files
    // debug!("cleaning up rcgu.* files");
    // let rcgu_files = util::scan_dir(&deps_dir, |stem, _| {
    //     stem.unwrap_or_default().contains("rcgu")
    // })?;
    // for file in rcgu_files {
    //     fs::remove_file(file)?;
    // }

    // clean up rmeta* folders
    debug!("cleaning up rmeta* folders");
    let rmeta_dirs = {
        let v = util::scan_dir(&deps_dir, |stem, extension| {
            stem.unwrap_or_default().contains("rmeta") && extension == None
        })?;
        v.into_iter()
            .filter(|path| fs::metadata(path).unwrap().is_dir())
            .collect::<Vec<PathBuf>>()
    };
    for dir in rmeta_dirs {
        fs::remove_dir(dir)?;
    }

    Ok(())
}

fn replace_obj_file(args: &BuildArgs, rlib_file: &String) -> CIResult<()> {
    // replace *.o with *_ci.o in rlib files

    // list all obj files
    let output = Command::new("ar").arg("-t").arg(rlib_file).output()?;
    if !output.status.success() {
        info!("status code: {:?}", output.status);
        info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        bail!("`ar` returned failed status code");
    }

    let rcgu_obj_file = String::from_utf8_lossy(&output.stdout);
    let rcgu_obj_file = match rcgu_obj_file
        .lines()
        .find(|e| e.contains("rcgu") && !e.contains("_ci"))
    {
        Some(v) => v,
        None => return Ok(()),
    };

    let mut deps_dir = util::target_dir(&args.target, &args.release, "deps")?;
    deps_dir.push(rcgu_obj_file);
    let rcgu_obj_file_name = deps_dir
        .file_stem()
        .and_then(|s| s.to_str())
        .ok_or_else(|| eyre!("failed to get file stem"))?;
    let mut rcgu_obj_ci_file = deps_dir.clone();
    rcgu_obj_ci_file.set_file_name(format!("{}_ci.o", rcgu_obj_file_name));

    // add rcgu_obj_ci_file before rcgu_obj_file
    let output = Command::new("ar")
        .arg("-rb")
        .arg(deps_dir)
        .arg(rlib_file)
        .arg(rcgu_obj_ci_file)
        .output()?;
    if !output.status.success() {
        info!("status code: {:?}", output.status);
        info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        bail!("`ar` returned failed status code");
    }

    // delete old rcgu_obj_file
    let output = Command::new("ar")
        .arg("-d")
        .arg(rlib_file)
        .arg(rcgu_obj_file)
        .output()?;
    if !output.status.success() {
        info!("status code: {:?}", output.status);
        info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        bail!("`ar` returned failed status code");
    }

    Ok(())
}
