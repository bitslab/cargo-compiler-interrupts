use anyhow::Context;
use cargo_util::paths;
use filetime::FileTime;
use std::fs;
use std::path::PathBuf;
use std::process::{Command, Output};
use tracing::{debug, info};

use super::cargo;
use super::util;

use crate::args;
use crate::CIResult;

pub(crate) fn run() -> CIResult<()> {
    let mut old_timestamp_binary_files = vec![];

    if let Ok(deps_dir) = util::target_dir("deps") {
        let binary_files = {
            let v = util::scan_dir(&deps_dir, |_, extension| extension == None)?;
            v.into_iter()
                .filter(|path| fs::metadata(path).unwrap().is_file())
                .collect::<Vec<PathBuf>>()
        };
        old_timestamp_binary_files = binary_files
            .iter()
            .map(|e| paths::mtime(e).unwrap())
            .collect::<Vec<FileTime>>();
    }

    // run `cargo build`
    let cargo_build_output = cargo::build()?;

    let deps_dir = util::target_dir("deps")?;

    let binary_files = {
        let v = util::scan_dir(&deps_dir, |_, extension| extension == None)?;
        v.into_iter()
            .filter(|path| fs::metadata(path).unwrap().is_file())
            .collect::<Vec<PathBuf>>()
    };

    let new_timestamp_binary_files = binary_files
        .iter()
        .map(|e| paths::mtime(e).unwrap())
        .collect::<Vec<FileTime>>();

    let num_newer_binary_file = if old_timestamp_binary_files.is_empty() {
        new_timestamp_binary_files.len()
    } else {
        old_timestamp_binary_files
            .iter()
            .zip(&new_timestamp_binary_files)
            .filter(|&(a, b)| a > b)
            .count()
    };

    if num_newer_binary_file == 0 {
        println!("nothing to integrate, all fresh");
        return Ok(());
    }

    // get *.ll files
    let ll_files = util::scan_dir(&deps_dir, |stem, extension| {
        // *.rcgu.ll are intermediate files generated by `rustc -C save-temps`
        let stem = stem.unwrap_or_default();
        stem.contains("rcgu") && !stem.contains("_ci") && extension == Some("ll")
    })?;

    // run CI integration
    let mut handlers = vec![];
    for file in ll_files {
        let handler = std::thread::spawn(move || {
            pre_ci_integration(&file)?;
            ci_integration(&file)?;
            post_ci_integration(&file)?;
            Ok::<(), anyhow::Error>(())
        });
        handlers.push(handler);
    }
    for handler in handlers {
        handler.join().expect("couldn't join thread")?;
    }

    // run linker
    linker(&cargo_build_output, num_newer_binary_file)?;

    Ok(())
}

fn pre_ci_integration(file: &PathBuf) -> CIResult<Output> {
    // first `opt` pass, pre-CI-integration optimization
    debug!("pre-integration: {}", file.display());
    let file_name = file
        .file_stem()
        .and_then(|s| s.to_str())
        .context("failed to get file stem")?;
    let out_file = file.with_file_name(format!("{}_opt.ll", file_name));
    let default_args = vec![
        "-S",
        "-postdomtree",
        "-mem2reg",
        "-indvars",
        "-loop-simplify",
        "-branch-prob",
        "-scalar-evolution",
    ]
    .iter()
    .map(|s| s.to_string())
    .collect::<Vec<String>>();
    let pre_ci_args = &args::get().pre_ci_args;
    let args = match !pre_ci_args.is_empty() {
        true => pre_ci_args,
        false => &default_args,
    };
    let output = util::opt(args, &file, &&out_file)?;
    Ok(output)
}

fn ci_integration(file: &PathBuf) -> CIResult<Output> {
    // second `opt` pass, integrate CI
    debug!("integration: {}", file.display());

    // get the binary and proc_macro name
    let mut bin_target_names = vec![];
    let metadata = cargo::metadata()?;
    for package in metadata.packages {
        for target in package.targets {
            let mut flag = true;
            for crate_type in target.crate_types {
                if crate_type != "bin" {
                    flag = false;
                }
            }
            for kind in target.kind {
                if kind != "bin" {
                    flag = false;
                }
            }
            if flag {
                bin_target_names.push(target.name.replace("-", "_"));
            }
        }
    }

    let file_name = file
        .file_stem()
        .and_then(|s| s.to_str())
        .context("failed to get file stem")?;

    let in_file = file.with_file_name(format!("{}_opt.ll", file_name));
    let out_file = file.with_file_name(format!("{}_ci.ll", file_name));

    // file_name: ci_demo.3imf9adxlnlmq03x.rcgu -> ci_demo
    let file_name = file_name.split(".").collect::<Vec<&str>>()[0].to_string();

    // skip "compiler-interrupt" crate
    let mut skip_crates = vec!["compiler_interrupt"];

    // crates that take an enormous amount of time to integrate
    skip_crates.append(&mut vec![
        "syn",
        "regex",
        "serde",
        "derive",
        "toml",
        "proc",
        "clap",
        "structopt",
    ]);

    if skip_crates.iter().any(|skip| file_name.contains(skip)) {
        // make a dummy _ci.ll file
        let output = util::cp(&in_file, &out_file)?;
        return Ok(output);
    }

    // define `LocalLC` only if it is a binary target
    let def_clock = match bin_target_names.contains(&file_name) {
        true => "-defclock=1",
        false => "-defclock=0",
    };

    let args = args::get();

    let ci_library_path = format!(
        "{}/lib/libcompilerinterrupt.so",
        std::env::var("CARGO_HOME").unwrap()
    );

    if !PathBuf::from(&ci_library_path).exists() {
        anyhow::bail!(
            "failed to locate `libcompilerinterrupt`, please reinstall `cargo-ci` \
            or manually specify the path to the library through --lib-path"
        );
    }

    let default_args = [
        "-S",
        "-load",
        &ci_library_path,
        "-compilerinterrupt",
        def_clock,
        "-clock-type=1",
        "-config=2",
        "-inst-gran=2",
        "-all-dev=100",
        "-push-intv=5000",
        "-commit-intv=1000",
        "-mem-ops-cost=1",
        "-fiber-config=5",
    ]
    .iter()
    .map(|s| s.to_string())
    .collect::<Vec<String>>();

    let ci_args = &args.ci_args;
    let args = match !ci_args.is_empty() {
        true => ci_args,
        false => &default_args,
    };

    let output = util::opt(args, &in_file, &out_file)?;
    Ok(output)
}

fn post_ci_integration(file: &PathBuf) -> CIResult<()> {
    debug!("post-integration: {}", file.display());
    let file_name = file
        .file_stem()
        .and_then(|s| s.to_str())
        .context("failed to get file stem")?;
    let opt_file = file.with_file_name(format!("{}_opt.ll", file_name));
    let ci_file = file.with_file_name(format!("{}_ci.ll", file_name));

    // transform IR bitcode to object file
    util::llc(&ci_file)?;

    // clean *_opt.ll
    fs::remove_file(opt_file.clone())
        .context(format!("failed to remove file: {}", opt_file.display()))?;

    Ok(())
}

fn linker(cargo_build_output: &Output, num_newer_binary_file: usize) -> CIResult<()> {
    // parse output from `cargo build` to get the final `cc` linker command
    debug!("running linker");
    let stdout = String::from_utf8_lossy(&cargo_build_output.stdout);
    let stdout = stdout.lines().collect::<Vec<&str>>();
    let cc_commands = stdout.iter().rev().take(num_newer_binary_file);

    for cc in cc_commands {
        debug!("cc: {}", cc);
        let cc = cc.replace("\"", "");
        let mut cc = cc
            .split_ascii_whitespace()
            .map(str::to_string)
            .collect::<Vec<String>>();

        let object_files = cc
            .iter_mut()
            .filter(|e| e.contains(".o") && !e.contains("_ci"));
        for file in object_files {
            // find the object file that contains the symbol for rust memory allocator
            // the reason for this is `rustc` is doing some hidden magic behind us
            // it uses llvm's code generation to create an allocator shim for the standalone binary
            // that object file doesn't get CI-integrated so we will have to find it for later use
            // we also need to invoke `rustc` with `-C save-temps` flags to not to delete the
            // temporary object file that contain allocator symbols

            // use `nm` tool to display symbol name
            // `-j` to just display the symbol names, `-U` to not display undefined symbols
            debug!("finding allocator shim: {}", file);
            let output = Command::new("nm").arg("-jU").arg(file.clone()).output()?;
            if !output.status.success() {
                info!("status code: {:?}", output.status);
                info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
                info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
                anyhow::bail!("`nm` returned failed status code");
            }
            let stdout = String::from_utf8_lossy(&output.stdout);
            if !stdout.contains("___rust_alloc") {
                let file_name = PathBuf::from(file.clone());
                let mut ci_file = file_name.clone();
                let file_name = file_name
                    .file_stem()
                    .and_then(|s| s.to_str())
                    .context("failed to get file stem")?;
                ci_file.set_file_name(format!("{}_ci.o", file_name));
                *file = ci_file.into_os_string().into_string().unwrap();
            }
        }

        let deps_rlib_files = cc
            .iter()
            .filter(|e| e.contains("deps") && e.contains(".rlib"));
        for file in deps_rlib_files {
            debug!("replacing object file: {}", file);
            replace_obj_file(file)?;
        }

        // execute
        debug!("executing cc");
        let mut iter = cc.iter();
        let mut cmd = Command::new(iter.next().unwrap());
        for arg in iter {
            cmd.arg(arg);
        }

        let output = cmd.output().context("failed to execute `cc`")?;

        if !output.status.success() {
            info!("status code: {:?}", output.status);
            info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
            info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
            anyhow::bail!("`cc` returned failed status code");
        }
    }

    let deps_dir = util::target_dir("deps")?;

    // clean up rcgu.* files
    // debug!("cleaning up rcgu.* files");
    // let rcgu_files = util::scan_dir(&deps_dir, |stem, _| {
    //     stem.unwrap_or_default().contains("rcgu")
    // })?;
    // for file in rcgu_files {
    //     fs::remove_file(file)?;
    // }

    // clean up rmeta* folders
    debug!("cleaning up rmeta* folders");
    let rmeta_dirs = {
        let v = util::scan_dir(&deps_dir, |stem, extension| {
            stem.unwrap_or_default().contains("rmeta") && extension == None
        })?;
        v.into_iter()
            .filter(|path| fs::metadata(path).unwrap().is_dir())
            .collect::<Vec<PathBuf>>()
    };
    for dir in rmeta_dirs {
        fs::remove_dir(dir)?;
    }

    Ok(())
}

fn replace_obj_file(rlib_file: &String) -> CIResult<()> {
    // replace *.o with *_ci.o in rlib files

    // list all obj files
    let output = Command::new("ar").arg("-t").arg(rlib_file).output()?;
    if !output.status.success() {
        info!("status code: {:?}", output.status);
        info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        anyhow::bail!("`ar` returned failed status code");
    }

    let rcgu_obj_file = String::from_utf8_lossy(&output.stdout);
    let rcgu_obj_file = match rcgu_obj_file
        .lines()
        .find(|e| e.contains("rcgu") && !e.contains("_ci"))
    {
        Some(v) => v,
        None => return Ok(()),
    };

    let mut deps_dir = util::target_dir("deps")?;
    deps_dir.push(rcgu_obj_file);
    let rcgu_obj_file_name = deps_dir
        .file_stem()
        .and_then(|s| s.to_str())
        .context("failed to get file stem")?;
    let mut rcgu_obj_ci_file = deps_dir.clone();
    rcgu_obj_ci_file.set_file_name(format!("{}_ci.o", rcgu_obj_file_name));

    // add rcgu_obj_ci_file before rcgu_obj_file
    let output = Command::new("ar")
        .arg("-rb")
        .arg(deps_dir)
        .arg(rlib_file)
        .arg(rcgu_obj_ci_file)
        .output()?;
    if !output.status.success() {
        info!("status code: {:?}", output.status);
        info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        anyhow::bail!("`ar` returned failed status code");
    }

    // delete old rcgu_obj_file
    let output = Command::new("ar")
        .arg("-d")
        .arg(rlib_file)
        .arg(rcgu_obj_file)
        .output()?;
    if !output.status.success() {
        info!("status code: {:?}", output.status);
        info!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        info!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        anyhow::bail!("`ar` returned failed status code");
    }

    Ok(())
}
