# Documentation

- [Objective](#objective)
- [Usage](#usage)
- [Project structure](#project-structure)
- [What are those files?](#what-are-those-files)
- [How does it work?](#how-does-it-work)
- [Limitations](#limitations)

## Objective

Since [Compiler Interrupts](https://pldi21.sigplan.org/details/pldi-2021-papers/82/Frequent-Background-Polling-on-a-Shared-Thread-using-Light-Weight-Compiler-Interrupt) is an LLVM pass, we want to extend `cargo` to support applying a third-party LLVM pass to the binary during the compilation process seamlessly. `cargo-ci` made specifically to integrate the Compiler Interrupts.

## Usage

`cargo-ci` provides three subcommands:

``` sh
cargo-build-ci
Compile and integrate the Compiler Interrupts to a local package

USAGE:
    cargo-build-ci [FLAGS] [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -r, --release    Build artifacts in release mode
    -v, --verbose    Use verbose output (-vv very verbose output)
    -V, --version    Prints version information

OPTIONS:
    -t, --target <TRIPLE>    Build for the target triple
```

``` sh
cargo-run-ci
Run a Compiler Interrupts-integrated binary

USAGE:
    cargo-run-ci [FLAGS] [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -r, --release    Run the binary in release mode
    -v, --verbose    Use verbose output (-vv very verbose output)
    -V, --version    Prints version information

OPTIONS:
    -b, --bin <bin>          Name of the binary
    -t, --target <TRIPLE>    Run for the target triple
```

``` sh
cargo lib-ci
Manage the Compiler Interrupts library.

USAGE:
    cargo-lib-ci [FLAGS] [OPTIONS] <--install|--uninstall>

FLAGS:
    -h, --help         Prints help information
    -i, --install      Install the library
    -u, --uninstall    Uninstall the library
    -v, --verbose      Use verbose output (-vv very verbose output)
    -V, --version      Prints version information

OPTIONS:
    -a, --args <args>...    Set default arguments for the library
    -p, --path <path>       Path to the library when installing
```

## Project structure

`cargo-ci` has the following project structure, some files are omitted for brevity.

``` sh
├── Cargo.toml
├── crates
│   └── cargo-util
└── src
    ├── args.rs
    ├── bin
    │   ├── build.rs
    │   ├── library.rs
    │   └── run.rs
    ├── cargo.rs
    ├── config.rs
    ├── lib.rs
    ├── ops
    │   ├── build.rs
    │   ├── library.rs
    │   ├── mod.rs
    │   └── run.rs
    └── util.rs
```

## What are those files?

- Root directory
  - `Cargo.toml` is the manifest file that contains the configuration of the package.
  - `crates` contains local external dependencies. For now, `cargo-ci` only depends on `cargo-util`, which is extracted from `cargo`.
  
- `src` contains the source code of `cargo-ci`.
  - `args.rs` — backbone of the CLI interface.
  - `cargo.rs` — `cargo` commands.
  - `config.rs` — handles configuration.
  - `util.rs` — helper functions.
  - `bin` — entry function of subcommands.
  - `ops` — main execution of subcommands.

## How does it work?

1. `cargo build-ci` will invoke `cargo build` with very verbose flag (`-vv`) and a bunch of extra flags to internal `rustc` invocations. Extra flags are:
    - `--emit=llvm-ir` — emit LLVM IR bitcode in the LLVM assembly language format.
    - `-C debuginfo=0` — not pollute the bitcode with debug symbols.
    - `-C save-temps` — save temporary files during the compilation.
    - `-Z print-link-args` — print the internal linker command.
2. After `cargo build` completed, we should have these:
    - Output from `cargo build` contains internal linker commands that are generated by `rustc` for every library and binary.
    - Object `*.o` files and IR bitcode in the LLVM assembly language `*.ll` files in the `$CARGO_TARGET_DIR/<build_mode>/deps` directory. Moreover, each file should have a corresponding intermediate version that contains `rcgu` (rust codegen unit) in their name.
    - Rust static library with extra metadata `*.rlib` files. These files are generated if the project has extra modules and dependencies.
3. Run `opt` twice on all intermediate IR bitcode `*.ll` files. First `opt` invocation is for built-in optimizations, second `opt` invocation is for integrating the Compiler Interrupts. All CI-integrated files have suffix `_ci` in their name.
4. Run `llc` to convert all CI-integrated IR bitcode `*.ll` files to object `*.o` files.
5. Parse the output from `cargo build` to get the linker command for the binary. The linker command consists a variety of arguments relating to output file, linking static system libraries, and most importantly, specifying `*.rlib` dependencies for the binary. Linker commands are printed when you run `cargo build-ci` with very verbose flag (`-vv`).
6. Find the allocator shim, which is a special intermediate object file that contains the symbols for the Rust memory allocator. `rustc` automatically generates the allocator shim behind the scene.
7. Replace the object file in the `*.rlib` with the CI-integrated one.
8. Execute the linker command again to output the final CI-integrated binary.

## Limitations

- `cargo build` outputs the artifacts for us to replace the object files with the CI-integrated one, then invoke the linker one more time to output the new CI-integrated binary. Therefore, we have to compile the binary twice.
- Assuming the Compiler Interrupts does not depend on built-in `opt` optimizations, we can make some changes to `rustc` so that it can load and register a third-party LLVM pass during the compilation, hence eliminating the `opt` stage and linking after that, making the process done in one go. For example, `clang` supports loading and registering a third-party LLVM pass by running `clang -Xclang -load -Xclang mypass.so`, albeit the usage are more complicated than `opt` and does not support built-in optimizations from `opt`.
- Since we have to depend on the build output, `cargo-ci` is not robust and error-prone. If `cargo` or `rustc` changes the output drastically, `cargo-ci` has to be updated accordingly.
- Compiler Interrupts integration is not fast on huge IR bitcode from crates such as `clap`, `derive`, `proc`, `regex`, `serde`, `syn`, `toml`,... We roughly estimate the integration process takes about an hour for 500,000 lines of IR bitcode on a x86-64 quad-core machine.
